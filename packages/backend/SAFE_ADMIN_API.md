# Safe Multi-Sig Admin API Documentation

This document covers the Safe multi-signature wallet integration for SuperPool admin operations, particularly pool creation through decentralized governance.

## Overview

The Safe multi-sig integration provides enhanced security for critical SuperPool operations by requiring multiple signature approvals before execution. This is particularly important for:

- Pool creation and configuration
- Admin parameter changes  
- Emergency actions
- Treasury management

## Architecture

```
Mobile App → Firebase Cloud Functions → Safe Multi-Sig → PoolFactory Contract
                                     ↓
                           Firestore (Transaction State)
```

The multi-sig workflow follows these steps:
1. **Preparation**: Admin prepares a transaction (e.g., pool creation)
2. **Signature Collection**: Safe owners sign the transaction hash
3. **Execution**: Once threshold met, transaction is executed on-chain

## Functions

### 1. createPoolSafe

Creates a Safe multi-signature transaction for pool creation.

**Endpoint**: `createPoolSafe`
**Authentication**: Required
**Method**: Cloud Function (Callable)

#### Request Parameters

```typescript
interface CreatePoolSafeRequest {
  poolOwner: string        // Ethereum address of pool owner
  maxLoanAmount: string    // Max loan amount in ETH (e.g., "1000")
  interestRate: number     // Interest rate in basis points (e.g., 500 = 5%)
  loanDuration: number     // Loan duration in seconds
  name: string            // Pool display name
  description: string     // Pool description
  chainId?: number        // Optional, defaults to 80002 (Polygon Amoy)
}
```

#### Response

```typescript
interface CreatePoolSafeResponse {
  success: boolean
  transactionHash: string      // Safe transaction hash for signing
  safeAddress: string         // Safe wallet address
  requiredSignatures: number  // Number of signatures needed
  currentSignatures: number   // Current signatures (always 0 initially)
  message: string
  poolParams?: any           // Sanitized pool parameters
}
```

#### Example Usage

```typescript
// Mobile app or admin dashboard
const result = await createPoolSafe({
  poolOwner: "0x742d35Cc6670C74288C2e768dC1E574a0B7DbE7a",
  maxLoanAmount: "1000",
  interestRate: 500,
  loanDuration: 2592000, // 30 days
  name: "SME Business Loans",
  description: "Small and medium enterprise lending pool with competitive rates"
});

console.log(`Transaction prepared: ${result.transactionHash}`);
console.log(`Requires ${result.requiredSignatures} signatures`);
```

#### Error Handling

- `unauthenticated`: User not authenticated
- `invalid-argument`: Invalid pool parameters
- `SAFE_NOT_SUPPORTED`: Chain not supported for Safe operations
- `SAFE_ADDRESS_NOT_CONFIGURED`: Safe address not configured in environment

---

### 2. signSafeTransaction

Adds a signature to a pending Safe transaction.

**Endpoint**: `signSafeTransaction`
**Authentication**: Required (Safe owner)
**Method**: Cloud Function (Callable)

#### Request Parameters

```typescript
interface SignSafeTransactionRequest {
  transactionHash: string  // Safe transaction hash from createPoolSafe
  signature?: string      // Optional signature (if not provided, generates one)
  chainId?: number        // Optional, defaults to 80002
}
```

#### Response

```typescript
interface SignSafeTransactionResponse {
  success: boolean
  transactionHash: string
  safeAddress: string
  currentSignatures: number
  requiredSignatures: number
  readyToExecute: boolean     // True when enough signatures collected
  message: string
  signatures?: SafeSignature[] // Array of current signatures
}
```

#### Example Usage

```typescript
// Safe owner signs the transaction
const result = await signSafeTransaction({
  transactionHash: "0xabc123...",
  signature: "0xdef456..." // Generated by wallet
});

if (result.readyToExecute) {
  console.log("Transaction ready for execution!");
} else {
  console.log(`${result.requiredSignatures - result.currentSignatures} more signatures needed`);
}
```

#### Error Handling

- `not-found`: Transaction not found
- `deadline-exceeded`: Transaction expired
- `permission-denied`: User not a Safe owner
- `invalid-argument`: Invalid signature
- `failed-precondition`: Transaction not in pending state

---

### 3. executeSafeTransaction

Executes a Safe transaction once enough signatures are collected.

**Endpoint**: `executeSafeTransaction`
**Authentication**: Required
**Method**: Cloud Function (Callable)

#### Request Parameters

```typescript
interface ExecuteSafeTransactionRequest {
  transactionHash: string  // Safe transaction hash
  chainId?: number        // Optional, defaults to 80002
}
```

#### Response

```typescript
interface ExecuteSafeTransactionResponse {
  success: boolean
  transactionHash: string      // Original Safe transaction hash
  executionTxHash: string     // On-chain execution transaction hash
  safeAddress: string
  poolId?: number            // Pool ID if pool creation transaction
  poolAddress?: string       // Pool contract address if pool creation
  message: string
}
```

#### Example Usage

```typescript
// Execute after enough signatures collected
const result = await executeSafeTransaction({
  transactionHash: "0xabc123..."
});

if (result.poolId) {
  console.log(`Pool created with ID: ${result.poolId}`);
  console.log(`Pool address: ${result.poolAddress}`);
}

// Track on-chain execution
console.log(`Execution transaction: ${result.executionTxHash}`);
```

#### Error Handling

- `already-exists`: Transaction already executed
- `failed-precondition`: Insufficient signatures or wrong status
- `EXECUTION_FAILED`: On-chain execution failed
- `PRIVATE_KEY_NOT_CONFIGURED`: Backend signing key not configured

---

### 4. listSafeTransactions

Lists and manages Safe transactions with filtering and pagination.

**Endpoint**: `listSafeTransactions`
**Authentication**: Required
**Method**: Cloud Function (Callable)

#### Request Parameters

```typescript
interface ListSafeTransactionsRequest {
  page?: number           // Page number (default: 1)
  limit?: number          // Items per page (default: 20, max: 50)
  status?: string         // Filter by status
  type?: string           // Filter by transaction type
  safeAddress?: string    // Filter by Safe address
  chainId?: number        // Filter by chain ID
}
```

**Status Values**:
- `pending_signatures`: Awaiting signatures
- `ready_to_execute`: Enough signatures, ready for execution
- `executed`: Successfully executed
- `failed`: Execution failed
- `expired`: Transaction expired

**Type Values**:
- `pool_creation`: Pool creation transactions
- `admin_action`: General admin actions

#### Response

```typescript
interface ListSafeTransactionsResponse {
  success: boolean
  transactions: SafeTransactionInfo[]
  totalCount: number
  page: number
  limit: number
  hasNextPage: boolean
  hasPreviousPage: boolean
  userIsSafeOwner: boolean  // Whether current user is Safe owner
}

interface SafeTransactionInfo {
  transactionHash: string
  safeAddress: string
  type: string
  status: string
  requiredSignatures: number
  currentSignatures: number
  signatures: Array<{
    signer: string
    signedAt?: Date
  }>
  createdBy: string
  createdAt: Date
  expiresAt: Date
  executionTxHash?: string
  executedAt?: Date
  poolParams?: any
  readyToExecute: boolean
}
```

#### Example Usage

```typescript
// List pending transactions
const result = await listSafeTransactions({
  status: "pending_signatures",
  type: "pool_creation",
  page: 1,
  limit: 10
});

result.transactions.forEach(tx => {
  console.log(`${tx.type}: ${tx.currentSignatures}/${tx.requiredSignatures} signatures`);
  if (tx.poolParams) {
    console.log(`Pool: ${tx.poolParams.name}`);
  }
});
```

#### Error Handling

- `unauthenticated`: User not authenticated
- Generic database errors are handled gracefully

---

## Database Schema

### safe_transactions Collection

```typescript
interface SafeTransactionDoc {
  transactionHash: string       // Safe transaction hash (document ID)
  safeAddress: string          // Safe wallet address
  safeTransaction: SafeTransaction // Transaction details for execution
  poolParams: any              // Pool creation parameters
  chainId: number              // Blockchain network ID
  status: TransactionStatus    // Current transaction status
  requiredSignatures: number  // Signatures needed
  currentSignatures: number   // Current signature count
  signatures: SafeSignature[] // Array of signatures
  createdBy: string           // Firebase UID of creator
  createdAt: Date             // Creation timestamp
  expiresAt: Date             // Expiration timestamp (7 days)
  type: string                // Transaction type
  
  // Execution fields
  executionTxHash?: string    // On-chain transaction hash
  executedAt?: Date          // Execution timestamp
  blockNumber?: number       // Execution block
  gasUsed?: string          // Gas consumed
  
  // Pool creation results
  poolId?: number           // Created pool ID
  poolAddress?: string      // Created pool address
  
  // Error handling
  error?: string            // Error message if failed
  failedAt?: Date          // Failure timestamp
}
```

---

## Environment Configuration

Required environment variables:

```bash
# Polygon Amoy Testnet
POLYGON_AMOY_RPC_URL=https://rpc-amoy.polygon.technology
SAFE_ADDRESS_AMOY=0x... # Deployed Safe wallet address
POOL_FACTORY_ADDRESS_AMOY=0x... # PoolFactory contract address

# Polygon Mainnet
POLYGON_MAINNET_RPC_URL=https://polygon-mainnet.g.alchemy.com/v2/...
SAFE_ADDRESS_POLYGON=0x... # Deployed Safe wallet address
POOL_FACTORY_ADDRESS_POLYGON=0x... # PoolFactory contract address

# Transaction execution
PRIVATE_KEY=0x... # Backend private key for transaction execution
```

---

## Security Considerations

### Multi-Sig Threshold
- **Testnet**: Minimum 2-of-3 signatures recommended
- **Mainnet**: Minimum 3-of-5 signatures recommended
- Threshold should be high enough for security but low enough for operational efficiency

### Signature Verification
- All signatures are verified against Safe owner addresses
- Only verified Safe owners can sign transactions
- Signatures are cryptographically verified using ethers.js

### Transaction Expiration
- Transactions expire after 7 days to prevent stale transaction execution
- Expired transactions are automatically marked as expired
- New transactions must be created if expired

### Access Control
- Only authenticated users can create transactions
- Only Safe owners can sign transactions
- Backend uses dedicated private key for execution (not user wallets)

---

## Integration Examples

### Mobile App Integration

```typescript
// 1. Admin creates pool via Safe
const createResult = await firebase.functions().httpsCallable('createPoolSafe')({
  poolOwner: wallet.address,
  maxLoanAmount: "1000",
  interestRate: 500,
  loanDuration: 2592000,
  name: "Business Loans",
  description: "SME lending pool"
});

// 2. Notify Safe owners about pending transaction
const transactionHash = createResult.data.transactionHash;
// Send push notifications, emails, etc.

// 3. Safe owners sign the transaction
const signature = await wallet.signMessage(ethers.getBytes(transactionHash));
const signResult = await firebase.functions().httpsCallable('signSafeTransaction')({
  transactionHash,
  signature
});

// 4. Execute when ready
if (signResult.data.readyToExecute) {
  const executeResult = await firebase.functions().httpsCallable('executeSafeTransaction')({
    transactionHash
  });
  
  console.log(`Pool created: ${executeResult.data.poolAddress}`);
}
```

### Admin Dashboard

```typescript
// List pending transactions for admin review
const transactions = await firebase.functions().httpsCallable('listSafeTransactions')({
  status: 'pending_signatures',
  type: 'pool_creation'
});

// Display transactions with signature status
transactions.data.transactions.forEach(tx => {
  console.log(`${tx.poolParams.name}: ${tx.currentSignatures}/${tx.requiredSignatures}`);
  
  // Show who has signed
  tx.signatures.forEach(sig => {
    console.log(`Signed by: ${sig.signer}`);
  });
});
```

---

## Testing

### Unit Tests
- All functions have comprehensive unit tests
- Mocked ethers.js and Firestore dependencies
- Test various error conditions and edge cases

### Integration Tests
- Deploy to Polygon Amoy testnet
- Create actual Safe wallet with test owners
- Execute full workflow: create → sign → execute

### Test Cases

1. **Happy Path**: Create transaction, collect signatures, execute successfully
2. **Insufficient Signatures**: Attempt execution before threshold met
3. **Expired Transaction**: Try to sign/execute expired transaction
4. **Invalid Signatures**: Submit invalid or unauthorized signatures
5. **Duplicate Signatures**: Safe owner tries to sign twice
6. **Network Errors**: Handle RPC failures and retries

---

## Monitoring and Logging

### Structured Logging
All functions use structured logging with:
- User ID (Firebase UID)
- Transaction hash
- Safe address
- Operation type
- Error details
- Execution metrics

### Metrics to Monitor
- Transaction creation rate
- Signature collection time
- Execution success rate
- Gas usage patterns
- Error frequencies

### Alerting
Set up alerts for:
- Failed executions
- Expired transactions
- Unusual signature patterns
- High gas consumption

---

## Migration and Deployment

### Safe Deployment
1. Deploy Safe wallet on target network
2. Configure owners and threshold
3. Update environment variables
4. Test with small transactions

### Function Deployment
```bash
cd packages/backend
pnpm build
firebase deploy --only functions
```

### Verification Steps
1. Verify Safe configuration
2. Test transaction creation
3. Test signature collection
4. Test execution with minimum threshold
5. Monitor logs and metrics

---

## Future Enhancements

### Planned Features
1. **Batch Transactions**: Execute multiple pool creations in one Safe transaction
2. **Delegation**: Allow Safe owners to delegate signing authority
3. **Time-lock**: Add mandatory delay between signature completion and execution
4. **Notification System**: Real-time notifications for signature requests
5. **Mobile Signing**: Deep links for mobile Safe app integration

### Integration Opportunities
1. **Safe SDK**: Upgrade to official Safe SDK when available
2. **Snapshot Governance**: Integrate with Snapshot for decentralized proposal creation
3. **Zodiac Modules**: Add specialized governance modules
4. **Cross-chain**: Support multi-chain Safe deployments

This comprehensive API documentation ensures proper implementation and usage of the Safe multi-sig integration for secure SuperPool administration.