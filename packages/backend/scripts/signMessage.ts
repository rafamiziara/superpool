import { Wallet } from 'ethers'
import fs from 'fs'
import path from 'path'

// Get nonce and timestamp from command line arguments
const args = process.argv.slice(2)
const [nonce, timestamp] = args

// Check if nonce and timestamp are provided
if (!nonce || !timestamp) {
  console.error('❌ Usage: pnpm signMessage <nonce> <timestamp>')
  process.exit(1)
}

// Define the correct path using __dirname
const privateKeyPath = path.join(__dirname, 'privateKey.pem')

// Add a check to ensure the file exists before reading
if (!fs.existsSync(privateKeyPath)) {
  console.error(`❌ Error: Private key file not found at ${privateKeyPath}.`)
  console.error('❌ Please run "pnpm generateKey" first to create the key pair.')
  process.exit(1)
}

// Read the private key from the generated file
let privateKey: string

try {
  privateKey = fs.readFileSync(privateKeyPath, 'utf8')
} catch (error) {
  console.error(`❌ Error: Could not read private key from ${privateKeyPath}.`)
  process.exit(1)
}

// Create a wallet instance from the private key
const wallet = new Wallet(privateKey)

// Construct the message to sign
// This message must exactly match the one generated by your backend function.
const messageToSign =
  `Welcome to SuperPool!\n\n` +
  `This request will not trigger a blockchain transaction.\n\n` +
  `Wallet address:\n${wallet.address}\n\n` +
  `Nonce:\n${nonce}\n` +
  `Timestamp:\n${timestamp}`

console.log(`Signing message for wallet: ${wallet.address}`)
console.log(`Message: \n${messageToSign}\n`)

// Sign the message
wallet
  .signMessage(messageToSign)
  .then((signature) => {
    console.log('✅ Generated Signature:')
    console.log(signature)
  })
  .catch((error) => {
    console.error('❌ Error signing message:', error)
    process.exit(1)
  })
